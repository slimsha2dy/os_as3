# os_as3
memory_release
	부모가 실행 시: 자식의 R권한 W로 변경 -> 가상 메모리 해제, 물리 메모리 해제
	자식이 실행 시: 부모의 R권한 W로 변경 -> 가상 메모리 해제
	alloc id가 같고, R 권한이면 다 W로 변경
	-> 내가 부모면 가상 메모리 해제 후 물리 메모리 해제
	-> 자식이면 가상 메모리만 해제

	커널: tmp, pmem, wq, rq
	tmp: vmem
	release 1
	wq, rq 순회하면서 id=1이고 R인 것들을 W로 변경
	가상메모리에서 1인 것을 해제
	(부모일시)물리메모리에서 id=1이고 pid=1인 것들을 해제

	프로세스: 자기 vmem에서 allocid를 받아서 해당되는 것들을 W로 바꾸는 것
		allocid와 pmem을 받아서 allocid에 해당되는 것들 해제


find_victim을 할 때 원하는 만큼의 frame을 확보하지 못하는 문제가 계속 발생
	10이 필요한대 6만 있는 경우 정책에 따라 비어 있는 frame을 반환해서 자리가 부족했음
		모든 frame을 순회해서 가장 작은 것을 반환해야 하는데 tmp를 0으로 시작해서
		0이 비어있고 모두 정책상 비교하는 것이 모두 같으면 0을 자꾸 뱉음
	유효하지 않은 것들을 자꾸 검사하면서 오류가 생김 -> valid를 확인하자

fork_and_exec할 때 allocation id와 page id를 이어받지 않게 해서 문제 발생

실행은 잘 됐지만 원하는 결과가 나오지 않음
	자식이 메모리 할당할 때 물리 메모리에 페이지 아이디가 다르게 나오는  현상
		22사이클: 할당 해제 시 테이블에서 valid(물리 메모리에 있는지)를 해제해주지 않아서 꼬임
		28사이클: 할당 시 갑자기 특정 페이지 테이블(18)의 값이 사라짐
			물리 메모리에서 find victim 후 tmp의 가상 메모리에서만 찾음
				즉 pid를 통해 찾아서 없애야 함
			즉 물리 메모리에서 할당 해제 후 해당 pid를 찾아가서 해제함으로 해결
	자식이 exit 시 release가 제대로 안 된건지 부모의 권한이 R로 나옴
		release할 때 공유 중인 페이지인지를 제대로 판단하지 못했음
		copied bit를 추가해서 복사되어 공유 중인 페이지인지를 알도록 함
	memory write시 테이블에 있는데도 새로 프레임에 할당하는 오류가 있음
		오타때매 나왔음
